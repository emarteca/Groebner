
\documentclass[letterpaper,12pt,titlepage,oneside,final]{book}
 

\newcommand{\package}[1]{\textbf{#1}} 
\newcommand{\cmmd}[1]{\textbackslash\texttt{#1}} 
\newcommand{\href}[1]{#1} 

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{algorithmicx}

\algnewcommand\algorithmicInput{\textbf{Input:}}
\algnewcommand\Input{\item[\algorithmicInput]}

\algnewcommand\algorithmicOutput{\textbf{Output:}}
\algnewcommand\Output{\item[\algorithmicOutput]}

\newcommand\abs[1]{\left|#1\right|}

\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}


\usepackage{ifthen}
\usepackage{indentfirst}
\newboolean{PrintVersion}
\setboolean{PrintVersion}{false} 

\usepackage{amsmath,amssymb,amstext}
\usepackage[pdftex]{graphicx}

\usepackage{lipsum}
\newcounter{examplecounter}
\newenvironment{example}{\begin{quote}%
    \refstepcounter{examplecounter}%
  \textbf{Example \arabic{examplecounter}}%
  \quad
}{%
\end{quote}%
}

\newcounter{definitioncounter}
\newenvironment{defn}{\begin{quote}%
    \refstepcounter{definitioncounter}%
  \textbf{Definition \arabic{definitioncounter}}%
  \quad
}{%
\end{quote}%
}

\newcounter{notecounter}
\newenvironment{note}{\begin{quote}%
    \refstepcounter{notecounter}%
  \textbf{Note \arabic{notecounter}}%
  \quad
}{%
\end{quote}%
}

\usepackage[pdftex,letterpaper=true,pagebackref=false]{hyperref} 

\usepackage[toc,page]{appendix}
    
\hypersetup{
    plainpages=false,       % needed if Roman numbers in frontpages
    pdfpagelabels=true,     % adds page number as label in Acrobat's page count
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={uWaterloo\ LaTeX\ Thesis\ Template},    % title: CHANGE THIS TEXT!
%    pdfauthor={Author},    % author: CHANGE THIS TEXT! and uncomment this line
%    pdfsubject={Subject},  % subject: CHANGE THIS TEXT! and uncomment this line
%    pdfkeywords={keyword1} {key2} {key3}, % list of keywords, and uncomment this line if desired
    pdfnewwindow=true,      % links in new window
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=blue,         % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}
\ifthenelse{\boolean{PrintVersion}}{   
\hypersetup{  % override some previously defined hyperref options
%    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black}
}{} % end of ifthenelse (no else)


\setlength{\marginparwidth}{0pt} 
\setlength{\marginparsep}{0pt}
\setlength{\evensidemargin}{0.125in}
\setlength{\oddsidemargin}{0.125in}
\setlength{\textwidth}{6.375in} 
\raggedbottom


\setlength{\parskip}{\medskipamount}


\renewcommand{\baselinestretch}{1} 

\let\origdoublepage\cleardoublepage
\newcommand{\clearemptydoublepage}{%
  \clearpage{\pagestyle{empty}\origdoublepage}}
\let\cleardoublepage\clearemptydoublepage

%======================================================================
%   L O G I C A L    D O C U M E N T -- the content of your thesis
%======================================================================
\begin{document}


%======================================================================
\chapter{Introduction}
%======================================================================

%----------------------------------------------------------------------
\section{Brief Overview and History of Groebner Bases}
%----------------------------------------------------------------------
 
The problem of solving for a Groebner basis was resolved by Bruno Buchberger in <YEAR>.  His algorithm (\textbf{Buchberger's Algorithm}, explained later in the text) was published in <SOME GARBAGE CONFERENCE PAPER> and it was not until <YEAR> at <SOME CONFERENCE> that the community realized that the algorithm existed and the implications of such.

Buchberger's algorithm was the initial approach, and since then there have been various different solutions 

\section{Intermediate Expression Swell}

Expression swell is a problem emergent in computer algebra.

Working with exact computations, where the numerical precision used is not bounded by the language, provides a platform for situations where as computations proceed the values stored keep increasing in size.  Consider multiplication of integers as an example.  Multiplying two n-digit integers results in a 2n-digit integer.  In computations involving sequential multiplication of integers, the product would get exponentially large.  Another example of expression swell can be seen in rational addition. Consider the following demonstrative example:

\begin{equation*}
  \frac{100}{101} + \frac{101}{102} = \frac{20401}{10302}
\end{equation*}

Here, the initial numerators and denominators are all 3-digit numbers, however their sum is a rational number with the numerator and denominator both 5 digits.  Addition of rational numbers results in expression swell as the greatest common denominator increases as more values are included in the sum.

This is not a problem in classic numerical programming languages where the precision of values stored is bounded by the language specifications.  However, when using a symbolic language where computations are exact, the precision is arbitrary and depends directly on the values stored.  Because of this essentially limitless precision, the results are accurate, however expression swell could potentially result in a large amount of memory being required to store values.

Intermediate expression swell is the special case of expression swell where the intermediate results of a computation have increasingly large values (i.e. suffer from expression swell), however this is not reflected in the final result.  This is not as simple to detect as regular expression swell; to be sure some or all of the intermediate computations must be displayed. 

Groebner basis computations are known to suffer from intermediate expression swell.  Generally the output basis does not reflect the size of the coefficients of the intermediate polynomials.  The intermediate coefficient growth is related to many factors of the original basis: degree, number of polynomials, initial coefficient size.  The values can grow to impractical size, slowing down the execution of the computation and perhaps even halting it if the program runs out of memory for storage.  

Consider the following demonstrative example, as provided by Arnolds:

\begin{eqnarray*}
  f_1 &=& 8x^2y^2 + 5xy^3 + 3x^3z + x^2yz\\
  f_2 &=& x^5 + 2y^3z^2 + 13y^2z^3 + 5yz^4\\ 
  f_3 &=& 8x^3 + 12y^3 + xz^2 + 3\\
  f_4 &=& 7x^2y^4 + 18xy^3z^2 + y^3z^3
\end{eqnarray*} 

As the input basis, while the output basis is computed as:

\begin{eqnarray*}
  g_1 &=& x\\
  g_2 &=& y^3 + \frac{1}{4}\\ 
  g_3 &=& z^2\\
\end{eqnarray*} 

The coefficients and for these polynomials are all less than 10; the resulting basis for ${B = [f_1, f_2, f_3, f_4]}$, with degree based monomial ordering\footnote{Referred to in her paper as DegRevLex, degree reverse lexicographical ordering; however this is equivalent to degree based ordering tdeg in Maple} ${x > y > z}$, given by ${G = [g_1, g_2, g_3]}$ also has small degree and coefficients.  However, the intermediate computations contain polynomials with very large coefficients, rational numbers commonly of 80 000 digits in both the numerator and denominator (CITE ARNOLDS HERE).  

This is a common occurrence in Groebner basis computations.  The size of the intermediate coefficients is not generally reflected in the final output of the normalized basis; it also depends on many factors (degree, initial coefficient size, initial basis size, initial ideal, monomial ordering chosen) and as such is hard to avoid.  Instead of attempting the difficult task of working around it, another solution to this problem will be attempted.



\chapter{Background}

There is some background mathematics necessary to the computation and discussion of Groebner bases.  This will build off assumed knowledge of basic groups and rings in order to explain the ideal theory needed.

\section{Algebraic Review}

There are various algebraic objects which one must be familiar with; this will be a brief introduction to these objects, assuming previous knowledge of the theory of groups and rings.  

There are various algebraic spaces with characterizations between rings and fields - notably, integral domains, unique factorization domains (henceforth UFDs), and Euclidean domains (henceforth EuDs).  These have their own properties, and once the space is extended (for example, by a variable or set of variables in the definition of a polynomial space) they have different relations between each other.  

Each will first be defined, building off the definition of a ring which is presumed known (but included for reference).

\begin{defn}\label{defn: Ring}
  A \textbf{ring} is a triple ${(R, +, *)}$ consisting of a non-empty set ${R}$ along with a pair of binary operations 

  \begin{equation*}
    + : R \times R \rightarrow R   \qquad \qquad * : R \times R \rightarrow R
  \end{equation*}

  such that:

  \begin{itemize}
    \item ${(R, +)}$ is an Abelian group
    \item ${*}$ is associative
    \item ${*}$ is distributive over ${+}$ i.e. ${\forall\, a, b, c\, \in\, R}$\begin{eqnarray*} a*(b+c) = (a*b) + (a*c) \\ (a+b)*c = (a*c) + (b*c) \end{eqnarray*} 
  \end{itemize}
\end{defn}

Rings can also be \textbf{commutative rings}, where the operation ${*}$ is also commutative (recall, ${+}$ is already commutative since ${(R, +)}$ is an Abelian group).  In addition, rings can be \textbf{rings with unity}; this is where ${R}$ has an identity with respect to ${*}$.  In order to construct the next algebraic structures, rings with unity will mainly be considered.

Similar to a ring, but with more specifications, there are integral domains.  

\begin{defn}\label{defn: Integral domain}
  An \textbf{integral domain} is a commutative ring with unity which satisfies the "cancellation law" i.e. \\
  \begin{equation*} \forall\, a, b, c\, \in R\, \mid \, a \cdot b = a \cdot c, \, a \neq 0\end{equation*}
  we must have ${b = c}$

  Note: this is equivalent to the "no zero divisors" law: whenever ${a \cdot b = 0}$, then either ${a = 0}$ or ${b = 0}$
\end{defn}

All integral domains are rings; they just have additional conditions which must be met in order to be categorized as such.

Similarly, there are also UFDs, which are integral domains with more restrictions.  These require the concepts of \textbf{units}, \textbf{associates}, and \textbf{primes}.  These definitions are not explicitly stated in the body of the text as they are more background, however they are included for reference in the Supplementary Definitions appendix \ref{appendix:definitions}.

\begin{defn}\label{defn: Unique Factorization Domain}
  An integral domain ${D}$ is a \textbf{unique factorization domain} (UFD) if for any ${a \in D - \{0\}}$,  either: 
  \begin{itemize}
    \item ${a}$ is a \textbf{unit}, or
    \item ${a = p_1 \cdot p_2 \cdot \ldots \cdot p_n}$ for primes ${p_i}$, and this factorization is unique up to \textbf{associates} and \textbf{reordering}
  \end{itemize}
\end{defn}

Another algebraic structure, building on UFDs, is a \textbf{Euclidean domain}.

\begin{defn}\label{defn: Euclidean domain}
  A \textbf{Euclidean domain} (EuD) is a UFD with a \\ \textbf{valuation function} ${v : D - \{0\} \leftarrow \mathbb{N}_0}$:
  \begin{itemize}
    \item ${v(a, b) \geq v(b) \;\; \forall \, a, b \in D - \{0\}}$
    \item ${\forall \, a, b \in D, b \neq 0, \exists \, q, r \in D \mid a = b \cdot q + r}$ where either ${r = 0}$ or ${v(r) < v(b)}$
  \end{itemize}
\end{defn}

Finally, there is the concept of a \textbf{field}, again building on the previous algebraic structures. 

\begin{defn}\label{defn: Field}
  A \textbf{field} is a commutative ring with unity ${(F, +, *)}$ in which:
  \begin{itemize}
    \item ${(F, +)}$ is an Abelian group
    \item ${(F - \{0\}, *)}$ is an Abelian group (i.e. every nonzero element in ${F}$ has an inverse with respect to ${*}$)
    \item ${*}$ is distributive over ${+}$
  \end{itemize}
\end{defn}

\begin{note}
  Every field is a EuD.

  \textbf{Proof}: For a space to be a EuD, it must have a valuation function ${v : F - \{0\} \leftarrow \mathbb{N}_0}$ satisfying the criteria listed above.
  Here, take the valuation function to be ${v(a) = 1 \, \forall \, a \, \in F - \{0\}}$, for ${F}$ field with unity 1.    
  \begin{itemize}
    \item ${v(a * b) = 1 \, \forall \, a, b \, \in F - \{0\}}$, since ${a * b \in F - \{0\} \forall \, a, b \, \in F - \{0\}}$, and ${v(a) = 1 \, \forall \, a \, \in F - \{0\}}$ \\ This satisfies the first condition of EuD, since ${v(a * b) = 1 \leq 1 = v(b) \, \forall \, a, b \, \in F - \{0\}}$
    \item ${a, b \, \in F, b \neq 0}$ \begin{equation*} a = b * q + r; \; q, r \, \in F, v(r) < v(b) \, \text{or} \, r = 0 \end{equation*} \\ Here, consider that ${v(a) = 1 \, \forall \, a \in F - \{0\}}$.  So, there is no ${r \in F - \{0\}}$ such that ${v(r) < v(b)}$ for some ${b \in F - \{0\}}$.  \\ So therefore, ${r = 0}$ \\ Then, ${a = b*q}$ for some ${q \in F - \{0\}}$ \\ Recall that in a field F, ${b^{-1} \exists \, \forall \, b \in F - \{0\}}$ \\ So, applying ${b^{-1}}$ to both sides, ${b^{-1} * a = q \; \in F \, \forall a, b \in F, b \neq 0}$ \\ This satisfies the second condition of EuD. 
  \end{itemize} 

  Therefore, every field is an EuD.
\end{note}


\section{Polynomials and Polynomial Ideals}

Polynomials are some of the most important and widely used algebraic objects in symbolic computation (CN).  Polynomial are defined as elements of an extension of a space S by one (or more, for multivariate) variables.  The polynomial spaces of interest are generally those where the space extended was a field i.e. where the coefficients are all elements in the field - in these cases the coefficients will have inverses with respect to both ring additive and multiplicative operations.  

Polynomials can be classified by their number of variables - when considering polynomial spaces, they are mainly divided into univariate and multivariate (greater than one variable) spaces.  The distinction between univariate and multivariates (and the conglomeration of all multivariates in this categorization) is due to the behaviour of algebraic spaces when extended by variables (i.e. the space may become another type of space, "lower" in the categorization of algebraic spaces, upon extension), as described below.

First, consider spaces consisting of univariate polynomials; this concept will later be extended to multivariate polynomials.

\begin{defn}\label{defn: Univariate Polynomial Space}
  Given commutative ring with unity ${(R, +, *)}$; write ${R[x]}$ to denote the set of all expressions of the form
  \begin{equation*}
    a(x) = \sum_{k=0}^{\infty} a_k x^k
  \end{equation*}
  where ${a_k \in R}$ (coefficients of ${a(x)}$) 
\end{defn}

The categorization of the initial space determines what type the univariate polynomial space will be.  The relations between these spaces when they are extended is shown in the below list, and in FIGURE 1.
\begin{itemize}
  \item ${D[x]}$ is a \textbf{commutative ring} for ${D}$ \textbf{commutative ring} 
  \item ${D[x]}$ is an \textbf{integral domain} for ${D}$ \textbf{integral domain} 
  \item ${D[x]}$ is a \textbf{UFD} for ${D}$ \textbf{UFD}
  \item ${D[x]}$ is a \textbf{UFD} for ${D}$ \textbf{EuD}
  \item ${D[x]}$ is a \textbf{EuD} for ${D}$ \textbf{field}; with valuation function ${v(p(x)) = deg(p(x))}$ 
\end{itemize}  

This leads to a few interesting points: for one thing, there will never be a polynomial field.  A polynomial extension over a field results in a EuD, and not a field.  This makes sense, as for a space to be a field every non-zero element in the set would need to have an inverse also in the set - and polynomials do not have inverses in the polynomial space (i.e. there are no polynomials ${p_1(x) \neq 1, p_2(x) \neq 1}$ such that ${p_1(x) \cdot p_2(x) = 1 \, \forall \, x}$).  So, a polynomial space cannot be a field.

Another point to consider is the extension of the concept to multivariate polynomials.  To approach this problem, multivariate polynomials can be represented as univariate polynomials extended recursively by the other variables.  This way, the same definitions and group relationships can be used in figuring out what type of space will be present.  

For example, consider a bivariate polynomial space over a ring.  This is equivalent to a univariate space over a univariate space over a ring.  A univariate space over a ring is a ring; then, again, a univariate space over a ring is a ring.  So, a bivariate space over a ring is a ring.

As a more involved example, consider a bivariate polynomial over a field.  The first "layer" to consider is a univariate extension of a field, which is a EuD.  Then, when this space is extended with another variable, this is now a EuD extended by a variable, which results in a UFD.  

\begin{note}
  There cannot be a univariate polynomial field (the "highest" algebraic structure possible for a univariate space is when the coefficient space is a field, and then the extension becomes a EuD).
  
  Similarly, there cannot be a bivariate (or greater than 2 variable) polynomial EuD (or field) - the "highest" algebraic structure is a UFD.
\end{note}      

A polynomial space has a basis which consists of polynomials in the space; like a basis for any other space, this is a set of linearly independent set elements which span the space.  The space can then be written as the set generated by the basis set of polynomials.  For example notation, consider:
EXAMPLE FROM NOTES

Polynomial ideals are essential to the groundwork necessary for Groebner bases; however, first the concept of ideals must be introduced.

\subsection{Ideals}

Ideals are another algebraic structure, building off of rings and ring structure.  

\begin{defn}\label{defn: Ideals}
  An additive subgroup N of ring ${(R, +, *)}$ is an \textbf{ideal} iff 
  \begin{equation*} aN \subseteq R \qquad ; \qquad Nb \subseteq R \; \forall a, b \in R \end{equation*}
  This criterion can be written equivalently as
  \begin{equation*} a*n, \, n*a \in N \, \forall \, n \in N, \, a \in R \end{equation*}
  
  In other words: ideals are groups over a ring which are closed with respect to the ring's multiplication operation i.e. every ideal N contains all of its cosets (and both left and right).  
\end{defn}

The idea of an ideal can be demonstrated in part by the following simple example.  

\begin{example}\label{ex: Simple ideal}
  One classic demonstrative example of an ideal is the even numbers over the integers.\\ 
  The even numbers forms an additive subgroup of the integers, since 
  \begin{itemize}
    \item the set of even numbers is non-empty (contains the additive identity, 0)
    \item every even number ${x}$ has additive inverse ${-x}$ which is also an even number for all even ${x}$
    \item the set is closed under addition, since the sum of 2 even numbers is always even
  \end{itemize}
  Now, for this group to be an ideal, it must satisfy the "absorption" property with respect to integer multiplication.\\
  However, consider the multiplication of integers:
  \begin{itemize}
    \item the product of 2 even integers is an even integer
    \item the product of an even and an odd integer is an even integer
  \end{itemize}
  So, the integer ring over integer multiplication and addition is an ideal.
\end{example}

The idea for ideals is similar to that of previous algebraic objects, however now it takes into account the idea of cosets.

All ideals are subrings in the ring in which they are considered.  Similarly to other sub-structures (subgroups, subrings, etc), ideals share the idea of proper and trivial.  In this case, a \textbf{proper ideal} is one which is a proper subring i.e. in which the set is a proper subset of the set considered in the ring.  If the ideal is an improper subring i.e. the set is the ring set itself, then this is labelled as a \textbf{unit ideal}.  

A simple extension to the idea of ideals is the concept of \textbf{principal ideals}.  This subset of ideals contains those which can be generated by a single element i.e. cyclic ideals.  Rings in which all ideals are principal are labelled \textbf{principal ideal rings}.  Note that if a ring is cyclic, then all ideals will be principal.  This is the case since in a cyclic ring, all subrings are cyclic.  Since ideals are subrings, it follows that all ideals in a cyclic ring are also cyclic.  Therefore, cyclic rings are principal ideal rings.  However, the converse does not hold i.e. the existence of a principal ideal does not mean that the ring itself is a principal ideal ring.  

Ideals can be specified over the subset of rings which are classified as more particular algebraic structures such as integral domains and fields.  In this case, the one of more interest is the \textbf{principal ideal domain}, which is an integral domain in which every ideal is principal.  

\begin{example}\label{ex: Principal ideal}
  
\end{example}

Noetherian Rings

Polynomial Ideals



\section{Monomial Ordering}

A \textbf{monomial} is a term consisting of the power product and the coefficient.  A polynomial consists of a sum of monomials.

Groebner bases are computed with respect to a particular monomial ordering; such an ordering must be defined for a given polynomial space.  For univariate polynomials, the ordering is fairly intuitive.

For polynomials ${p(x), q(x) \in}$ polynomial space ${D[x], \, p(x) = a_n x^n + a_{n-1} x^{n-1} + \ldots + a_1 x + a_0,}$ \\ ${\, a_i \in D\, q(x) = b_m x^m + b_{m-1} x^{m-1} + \ldots + b_1 x + b_0, \, b_i \in D}$, the ordering is defined as 
\begin{equation*}
  p(x) > q(x) \iff \, \textrm{either} \, n > m \, \textrm{or} \, n = m \; \textrm{and} \; \exists \, a_i > b_i \neq 0, \, \textrm{where} \, a_k = b_k \, \forall k > i 
\end{equation*}
This is a rather complex notation for the intuitive idea for univariate polynomial ordering.  In simpler terms, polynomial ${p > }$ polynomial ${q}$ if ${p}$ has a higher degree, or if they have the same degree, then if ${p}$ has higher values for one or more of its higher order coefficients.

\begin{example}\label{ex: Univariate ordering}
  Consider basic polynomials over the integers.
  \begin{equation*}
    2x^2 + 3x > 5x
  \end{equation*}
  Since the first polynomial is of higher degree.\\
  \begin{equation*}
    3x^2 + 2x > 2x^2 + 5x + 1
  \end{equation*}
  Since the polynomials are of equal degree, but ${3 > 2}$\\
  \begin{equation*}
    3x^2 + 2x > 3x^2 + 5
  \end{equation*}
  Since the polynomials are of equal degree but ${2x}$ is of higher degree than ${5}$
\end{example}

The idea of ordering can be extended to multivariate polynomials, however this requires slightly more work, as the concept is not as intuitive.  While ordering for univariate polynomials is strictly degree-based, when considering multivariate polynomials, the ordering must be considered both degree-wise and lexicographically.  The same polynomials can be ordered in various different ways depending on the monomial ordering chosen; this in turn can have large effects on the efficiency of algorithms working over this polynomial space, including the Groebner basis algorithms.

Whether degree-based or lexicographical (known henceforth as lex) ordering is selected, the variables must still be ordered with respect to each other i.e. an ordering must be chosen.  Then, in degree ordering the total degree is the first factor considered; so, monomials with a higher total degree are considered greater regardless of the degrees of the individual variables making up the monomial.  Then, if the total degree is the same, ordering is lexicographical given the order specified.  For lex, the ordering is the variable ordering specified.

To explain the differences and functionality of degree and lex ordering, demonstrative examples will be used.  

\begin{example}\label{ex: Multivariate degree ordering}
  Consider the polynomials ${x^2y^2, xy^3, x^3y, x^4y}$, with ordering ${x > y}$.\\
  The degree-based ordering would be as follows:
  ${x^4y >}$ everything else, since it has total degree 5 (sum of exponents) while the rest of the monomials have total degree 4.\\
  Then, ${x^3y > x^2y^2 > xy^3}$ since, when the total degrees are identical, then the ordering is based on the degree of the "greater" variable.

  Similarly, if the initial variable ordering chosen was ${y > x}$, the ordering would be as follows:
  ${x^4y >}$ everything else, since total degree is still 5.  Then, ${xy^3 > x^2y^2 > x^3y}$, since now ordering is with respect to y i.e. y is the "greater" variable.
\end{example}

In contrast, consider the same example but with lex ordering instead.
\begin{example}\label{ex: Multivariate lex ordering}
  Consider again the polynomials ${x^2y^2, xy^3, x^3y, x^4y}$, with ordering ${x > y}$.\\
  The lex ordering would be as follows:
  Then, ${x^4y > x^3y > x^2y^2 > xy^3}$ since the ordering is chosen with respect to the degree of ${x}$ alone (in the event of a tie in degree, then the ordering would be considered with respect to the degree of ${y}$).

  Similarly, if the initial variable ordering chosen was ${y > x}$, the ordering would be as follows:
  ${xy^3 > x^2y^2 >}$ the other terms, since degree in ${y}$ is the ordering factor (recall, the remaining terms have ${y^1}$).\\
  Then, for the remaining terms, ${x^4y > x^3y}$ since, as they have the same degree in ${y}$, ordering is now considered with respect to degree in ${x}$.
\end{example}

These ordering techniques can be applied to polynomials with an arbitrary number of variables.  Although not immediately clear from the concepts, the monomial ordering chosen (either degree-based or lex, and, within this choice, the ordering of the variables chosen) can have a large effect on the efficiency of the Groebner basis computations.  The same problem can be considered with different orderings and have massively different timings for the computations (as will be seen below with tested examples).


\section{Groebner Basis Characterization}

Polynomial ideals can be specified by a basis; this specifies a linearly independent generating set for the ideal.  However, this basis is not unique - there are many possible configurations or potential elements which could make up a basis for the ideal.  

A Groebner basis is a particular basis for a polynomial ideal, which satisfies various conditions, detailed below.  There are various advantages to this set.  The normalized Groebner basis is unique to each ideal, and can therefore be used as a sort of identifier for the ideal. 

There are various logically equivalent definitions for what makes a basis a Groebner basis.  One definition is as follows: 

\begin{defn}\label{Groebner Basis}
  G is a Groebner basis for ideal $I = <p_1, \ldots, p_n>$ over polynomial ring $F[x_1, \ldots, x_m]$ for a particular monomial ordering iff
  \begin{equation*}
    p \in I \iff Reduce( p, G) = 0
  \end{equation*}
\end{defn}

This definition, although concise, is not complete alone; the Reduce function has not been defined.

This concept of reduction is essential to Groebner bases, and to the computation of the bases using Buchberger's Algorithm.  Reduction can be defined of a polynomial over another polynomial, or a polynomial over a set of polynomials (such as in the definition above, ${Reduce( p, G)}$, reduction of polynomial ${p}$ over set ${G}$).  

Reducing polynomial ${p}$ over another polynomial ${q}$, ${Reduce( p, q)}$ amounts to multivariate division of ${\frac{p}{q}}$.  This is a recursive extension of the Euclidean algorithm for division of univariate polynomials, dependent on the monomial ordering specified.  The idea is to consider the multivariate polynomial as a "recursive univariate polynomial".  This concept is best described by an example: consider the polynomial ${}$ EXAMPLE ON THE SYMBOLIC MIDTERM FOR POLYNOMIAL LONG DIVISION.

A polynomial ${p}$ is considered \textbf{reducible} over polynomial ${q}$ if a monomial in ${p}$ can be written as a multiple of the leading monomial of ${q}$.  It is \textbf{irreducible} if there are no monomials in ${p}$ which are multiples of the leading monomial os ${q}$.    

\begin{note}
  The \textbf{leading monomial} of a polynomial is the monomial with the highest order with respect to the monomial ordering specified.
\end{note}   

Reduction over a set ${G}$ of polynomials is the iterative application of the ${Reduce}$ over each of the polynomials in the set, until it is irreducible over the whole set.  This reduced polynomial is termed the \textbf{normal form} of the polynomial with respect to the set.

Referring back to the definition of a Groebner basis above, the ${Reduce}$ can now be considered more precisely: a Groebner basis is a basis for a polynomial ideal ${I}$ over field ${F}$; polynomial ${p \in I}$ is a member of the basis if and only if it is irreducible over the basis.  This has the implication that every polynomial which is irreducible over the set is in the set; every other polynomial in the ideal has a leading monomial which is a multiple of one or more elements in the set.

\subsection{Buchberger's Algorithm}

The first algorithm for computing Groebner bases was proposed by Bruno Buchberger in 1965, when he presented the concept of the bases themselves.  This algorithm is fairly short in writing, but the complexity of the algorithm cannot be seen intuitively seen from the logic itself.  The algorithm is presented below in pseudocode.

\begin{algorithm}
\caption{Buchberger}\label{buchberger}
\begin{algorithmic}[1]
\Input $\quad P$ generating set for a polynomial ideal; $ord$ monomial ordering
\Output Groebner Basis for the ideal generated by $P$
\Procedure{Buchberger}{}
\State $G \gets P$
\State $k \gets length( G)$
\State $B \gets \{[i, j] : 1 \leq i < j \leq k\}$\\
\While{ $B \neq \phi$}
  \State $[i, j] \gets selectpair( B, G)$
  \State $B \gets B - \{[i, j]\}$
  \State $h \gets Reduce( Spoly( G_i, G_j), G)$
  \If{ $h \neq 0$}
    \State $G \gets G \bigcup \{h\}; \qquad k \gets k + 1$
    \State $B \gets B \bigcup \{[i, k] : 1 \leq i < k\}$
  \EndIf
\EndWhile\\
\Return $G$
\EndProcedure
\end{algorithmic}
\end{algorithm}  

The basic idea is to start with a basis (i.e. a generating set) for the ideal, and repeatedly iterate over the set until all of the polynomials which are irreducible over the set are added to the set.  This is repeated until every combination of polynomials is either in the set or irreducible over the set.  Notice the call to ${Reduce}$; this is the reduction of a polynomial over the set ${G}$ as discussed above.   

One new concept which the algorithm requires is the computation of \textbf{S-polynomials}.  Computation of S-polynomials is done through the following formula: 

\begin{equation*}
  Spoly( p, q) = LCM(M(p), M(q)) \left( \frac{p}{M(p)} - \frac{q}{M(q)}\right)
\end{equation*}

\begin{note}
  A note on notation in the definition of S-polynomials, but which will be used elsewhere
  \begin{itemize}
    \item ${LCM}$ is the least common multiple
    \item ${M(p)}$ is the leading monomial of polynomial ${p}$, with the monomial ordering considered
  \end{itemize}
\end{note}

The S-polynomial is essentially an application of the reduction process; the result is the difference between the reduction of the LCM modulo ${p}$ and modulo ${q}$.  In the Buchberger algorithm, the S-polynomial is the tool by which it can be determined if the polynomial is reducible over the set and therefore whether or not to add it to the existing set.  To demonstrate the calculation process, an example of an S-polynomial derivation is included below.

\begin{example}\label{S-polynomial}
  Consider polynomials ${p, \, q \in }$ $\mathbb{Q}$, given by 
  \begin{equation*}
    p = 3x^2y - y^3 - 4 \qquad ; \qquad q = xy^3 + x^2 -9
  \end{equation*}
  under monomial ordering ${tdeg(x, y}$ (i.e. degree based ordering ${x > y}$)
  
  To find the S-polynomial ${Spoly( p, q)}$, first the leading monomials with respect to ${tdeg( x, y)}$ must be computed, in addition to their LCM.
  \begin{eqnarray*}
    M( p) &=& 3x^2y\\
    M( q) &=& xy^3\\\\
    LCM( M( p), M( q)) &=& 3x^2y^3
  \end{eqnarray*}
  
  So then, to calculate the S-polynomial
  \begin{eqnarray*}
    Spoly( p, q) &=& 3x^2y^3(\frac{3x^2y - y^3 - 4}{3x^2y} - \frac{xy^3 + x^2 -9}{xy^3})\\
           &=& y^2(3x^2y - y^3 - 4) - 3x(xy^3 + x^2 -9)\\
           &=& -y^5 - 3x^3 - 4y^2 + 27x 
  \end{eqnarray*}
\end{example}

At this point all the necessary constructs for applying Buchberger's algorithm are present.  To demonstrate how this process is applied, an example walkthrough of the algorithm's execution is included for clarity.  Recall that as input, the algorithm requires a generating set for the polynomial ideal, and a monomial ordering specified.

EXAMPLE FROM NOTES

\subsubsection{F4 Algorithm}

Since the introduction of Groebner bases by Buchberger in 1965, there have been various improvements on his algorithm for basis computation.  Notably, there is the F4 algorithm, developed by Faugere.  There are F4 implementations in the Maple Groebner package (maplef4 algorithm, and efficient C implementation in the FGB algorithm).

This is a more efficient ..... 


Regardless of the improvements in speed of these algorithms, one problem which they all face is intermediate expression swell, as discussed above.  Groebner basis computations, depending on the intial ideal, can give rise to unmanagable expression swell.  This cannot be avoided by using classic iterative algorithms; however, these are the only algorithms currently available.  Instead of inventing an entirely new algorithmic approach, which may not even be possible, another potential approach would be to use the regular algorithms over prime fields, and then reconstruct the solution to the original space via a homomorphism method.


\section{Chinese Remainder Algorithm}




\section{Hensel's Algorithm}


\begin{appendices}

\section{Supplementary Definitions}
\label{appendix:definitions}

\appendix{}

This contains definitions which are presumed known and not explicitly declared in the text, but are referred to in passing.  They are included here for clarity.

\begin{defn}\label{defn: Unit}
  An element ${u \in D, \, D}$ domain, is a \textbf{unit} (\textbf{invertible}) if ${u}$ has a multiplicative inverse (i.e. with respect to operation ${*\,}$in ${D}$).

  For example, in $\mathbb{Z}$, the units are 1 and -1.
\end{defn}

\begin{defn}\label{defn: Associate}
  Two elements ${a, b \in D, \, D}$ domain, are \textbf{associates} if ${a \mid b}$ and ${b \mid a}$ i.e. they are multiples they are related via multiplication of a unit. 
\end{defn}

\begin{defn}\label{defn: Prime}
  An element ${p \in D - \{0\}, \, D}$ domain, is a \textbf{prime} if
  \begin{itemize}
    \item ${p}$ is \textbf{not} a unit
    \item whenever ${p = a \cdot b}$, for ${a, b \in D}$, then either ${a}$ or ${b}$ is a unit (but not both, since ${p}$ is not a unit)
  \end{itemize}
\end{defn}

\end{appendices}






%----------------------------------------------------------------------
% END MATERIAL
%----------------------------------------------------------------------

% B I B L I O G R A P H Y
% -----------------------

% The following statement selects the style to use for references.  It controls the sort order of the entries in the bibliography and also the formatting for the in-text labels.
\bibliographystyle{plain}
% This specifies the location of the file containing the bibliographic information.  
% It assumes you're using BibTeX (if not, why not?).
\cleardoublepage % This is needed if the book class is used, to place the anchor in the correct page,
                 % because the bibliography will start on its own page.
                 % Use \clearpage instead if the document class uses the "oneside" argument
\phantomsection  % With hyperref package, enables hyperlinking from the table of contents to bibliography             
% The following statement causes the title "References" to be used for the bibliography section:
\renewcommand*{\bibname}{References}

% Add the References to the Table of Contents
\addcontentsline{toc}{chapter}{\textbf{References}}

\bibliography{uw-ethesis}
% Tip 5: You can create multiple .bib files to organize your references. 
% Just list them all in the \bibliogaphy command, separated by commas (no spaces).

% The following statement causes the specified references to be added to the bibliography% even if they were not 
% cited in the text. The asterisk is a wildcard that causes all entries in the bibliographic database to be included (optional).
\nocite{*}

\end{document}